<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ngsaipp: ngsai::dna Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ngsaipp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacengsai.html">ngsai</a></li><li class="navelem"><a class="el" href="namespacengsai_1_1dna.html">dna</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ngsai::dna Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1dna_1_1SequenceEnumerator.html">SequenceEnumerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1587df10a244c8a82309c0fbe0c0178d"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; char, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a1587df10a244c8a82309c0fbe0c0178d">base_pairing</a> ({{ 'A', 'T'}, { 'C', 'G'}, { 'G', 'C'}, { 'T', 'A'}, { 'N', 'N'}})</td></tr>
<tr class="memdesc:a1587df10a244c8a82309c0fbe0c0178d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map containing the reverse complement of each DNA base.  <br /></td></tr>
<tr class="separator:a1587df10a244c8a82309c0fbe0c0178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1b7328bde664b8aa78a889c9371297"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; char, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#ada1b7328bde664b8aa78a889c9371297">base_code</a> ({{ 'A', 0}, { 'C', 1}, { 'G', 2}, { 'T', 3}})</td></tr>
<tr class="memdesc:ada1b7328bde664b8aa78a889c9371297"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map containing an int code corresponding to each DNA base.  <br /></td></tr>
<tr class="separator:ada1b7328bde664b8aa78a889c9371297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d8261487b1304f0650d83af40c6682"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; int, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a34d8261487b1304f0650d83af40c6682">code_base</a> ({{0, 'A'}, {1, 'C'}, {2, 'G'}, {3, 'T'}})</td></tr>
<tr class="memdesc:a34d8261487b1304f0650d83af40c6682"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map containing the DNA base corresponding to each int code.  <br /></td></tr>
<tr class="separator:a34d8261487b1304f0650d83af40c6682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540de6a16773c5f73469c0cdd348b17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a3540de6a16773c5f73469c0cdd348b17">get_reverse_complement</a> (const std::string &amp;seq)</td></tr>
<tr class="memdesc:a3540de6a16773c5f73469c0cdd348b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reverse complement of a DNA sequence.  <br /></td></tr>
<tr class="separator:a3540de6a16773c5f73469c0cdd348b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ae069839db303cbe98519b82628e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a0e8ae069839db303cbe98519b82628e6">colored_dna_seq</a> (const std::string &amp;seq)</td></tr>
<tr class="memdesc:a0e8ae069839db303cbe98519b82628e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new string containing a formatted DNA sequence that appears colored when printed on a terminal. Only DNA characters (A, C, G, T, N) are colored.  <br /></td></tr>
<tr class="separator:a0e8ae069839db303cbe98519b82628e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874212e5dc60ea9a5cef5eb90ce59d2c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a874212e5dc60ea9a5cef5eb90ce59d2c">hash_kmer</a> (const std::string &amp;sequence)</td></tr>
<tr class="memdesc:a874212e5dc60ea9a5cef5eb90ce59d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash for the given sequence. The hash represents the index at which the sequence would be located if all possible sequences of the same length were sorted. This function is designed for fixed length squences. The hashes of sequences of different lengths should not be compared.  <br /></td></tr>
<tr class="separator:a874212e5dc60ea9a5cef5eb90ce59d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc505e91b9257703455215130e5f2df9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#acc505e91b9257703455215130e5f2df9">hash_kmer</a> (const std::string &amp;sequence, size_t start, size_t length)</td></tr>
<tr class="memdesc:acc505e91b9257703455215130e5f2df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash for the sub-sequence starting at the given position in the sequence and of the given length. The hash represents the index at which the sub-sequence would be located if all possible sequences of the same length were sorted. This function is designed for fixed length sequences. The hashes of sequences of different lengths should not be compared.  <br /></td></tr>
<tr class="separator:acc505e91b9257703455215130e5f2df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a31577c9216f1e8e3338bae26da07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a599a31577c9216f1e8e3338bae26da07">hash_kmer</a> (const std::string &amp;sequence, size_t kmer_size)</td></tr>
<tr class="memdesc:a599a31577c9216f1e8e3338bae26da07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash each kmer (at every offset) in the sequence using a Rabin-Karp rolling hash implementation. The hash represents the index at which the kmers would be located if all possible kmers with this length were sorted. This function is designed for fixed length kmers. The hashes of kmers of different lengths should not be compared.  <br /></td></tr>
<tr class="separator:a599a31577c9216f1e8e3338bae26da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace82f34150416da314e1dbbc1f9aa540"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#ace82f34150416da314e1dbbc1f9aa540">hash_kmer</a> (const std::string &amp;sequence, std::vector&lt; std::string &gt; &amp;kmer_sequences, size_t kmer_size)</td></tr>
<tr class="memdesc:ace82f34150416da314e1dbbc1f9aa540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash each kmer (at every offset) in the sequence using a Rabin-Karp rolling hash implementation. The kmer hashes are returned and the kmer sequences are stored in the given vector. The hash represents the index at which the kmers would be located if all possible kmers with this length were sorted. This function is designed for fixed length kmers. The hashes of kmers of different lengths should not be compared.  <br /></td></tr>
<tr class="separator:ace82f34150416da314e1dbbc1f9aa540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d044987fc2942a4c3cfa20e44a07ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#ae0d044987fc2942a4c3cfa20e44a07ca">hash_kmer</a> (const std::string &amp;sequence, const std::vector&lt; uint32_t &gt; &amp;ipds, const std::vector&lt; uint32_t &gt; &amp;pwds, std::vector&lt; std::string &gt; &amp;kmer_sequences, std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;kmer_ipds, std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;kmer_pwds, size_t kmer_size)</td></tr>
<tr class="memdesc:ae0d044987fc2942a4c3cfa20e44a07ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the same as the previous function but also stored the IPDs/PWDs corresponding to each kmer in the corresponding vectors.  <br /></td></tr>
<tr class="separator:ae0d044987fc2942a4c3cfa20e44a07ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a40371e0fb437e53989372541555323c7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html#a40371e0fb437e53989372541555323c7">dna_alphabet_size</a> = base_code.size()</td></tr>
<tr class="memdesc:a40371e0fb437e53989372541555323c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the DNA character set.  <br /></td></tr>
<tr class="separator:a40371e0fb437e53989372541555323c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada1b7328bde664b8aa78a889c9371297" name="ada1b7328bde664b8aa78a889c9371297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1b7328bde664b8aa78a889c9371297">&#9670;&#160;</a></span>base_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; char, int &gt; ngsai::dna::base_code </td>
          <td>(</td>
          <td class="paramtype">{{ 'A', 0}, { 'C', 1}, { 'G', 2}, { 'T', 3}}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map containing an int code corresponding to each DNA base. </p>

</div>
</div>
<a id="a1587df10a244c8a82309c0fbe0c0178d" name="a1587df10a244c8a82309c0fbe0c0178d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1587df10a244c8a82309c0fbe0c0178d">&#9670;&#160;</a></span>base_pairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; char, char &gt; ngsai::dna::base_pairing </td>
          <td>(</td>
          <td class="paramtype">{{ 'A', 'T'}, { 'C', 'G'}, { 'G', 'C'}, { 'T', 'A'}, { 'N', 'N'}}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map containing the reverse complement of each DNA base. </p>

</div>
</div>
<a id="a34d8261487b1304f0650d83af40c6682" name="a34d8261487b1304f0650d83af40c6682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d8261487b1304f0650d83af40c6682">&#9670;&#160;</a></span>code_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; int, char &gt; ngsai::dna::code_base </td>
          <td>(</td>
          <td class="paramtype">{{0, 'A'}, {1, 'C'}, {2, 'G'}, {3, 'T'}}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map containing the DNA base corresponding to each int code. </p>

</div>
</div>
<a id="a0e8ae069839db303cbe98519b82628e6" name="a0e8ae069839db303cbe98519b82628e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ae069839db303cbe98519b82628e6">&#9670;&#160;</a></span>colored_dna_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::dna::colored_dna_seq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new string containing a formatted DNA sequence that appears colored when printed on a terminal. Only DNA characters (A, C, G, T, N) are colored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>the DNA sequence of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string containing the original DNA sequence plus some formatting characters. </dd></dl>

</div>
</div>
<a id="a3540de6a16773c5f73469c0cdd348b17" name="a3540de6a16773c5f73469c0cdd348b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540de6a16773c5f73469c0cdd348b17">&#9670;&#160;</a></span>get_reverse_complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::dna::get_reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the reverse complement of a DNA sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>A DNA sequence of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence contains a non-DNA character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reverse complement of the given DNA sequence. </dd></dl>

</div>
</div>
<a id="a874212e5dc60ea9a5cef5eb90ce59d2c" name="a874212e5dc60ea9a5cef5eb90ce59d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874212e5dc60ea9a5cef5eb90ce59d2c">&#9670;&#160;</a></span>hash_kmer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ngsai::dna::hash_kmer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a hash for the given sequence. The hash represents the index at which the sequence would be located if all possible sequences of the same length were sorted. This function is designed for fixed length squences. The hashes of sequences of different lengths should not be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the kmer to compute the hash from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence contains an invalid DNA character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kmer hash. </dd></dl>

</div>
</div>
<a id="ae0d044987fc2942a4c3cfa20e44a07ca" name="ae0d044987fc2942a4c3cfa20e44a07ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d044987fc2942a4c3cfa20e44a07ca">&#9670;&#160;</a></span>hash_kmer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; ngsai::dna::hash_kmer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ipds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>kmer_sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kmer_ipds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kmer_pwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the same as the previous function but also stored the IPDs/PWDs corresponding to each kmer in the corresponding vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence of interest. </td></tr>
    <tr><td class="paramname">ipds</td><td>the IPD values corresponding to each sequence position. </td></tr>
    <tr><td class="paramname">pwds</td><td>the PWD values corresponding to each sequence position. </td></tr>
    <tr><td class="paramname">kmer_size</td><td>the size of the kmer to hash from the sequence. </td></tr>
    <tr><td class="paramname">kmer_sequences</td><td>a vector in which each kmer sequence will be stored. The sequence order will match the hash order. </td></tr>
    <tr><td class="paramname">kmer_ipds</td><td>a vector in which each kmer IPD values will be stored. The IPD order will match the hash order. </td></tr>
    <tr><td class="paramname">kmer_pwds</td><td>a vector in which each kmer PWD values will be stored. The PWD order will match the hash order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence is too short to contain the given kmer, if it contains an invalid DNA character or if the sequence, IPDs and PWDs length do not match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the hashes of each kmer, starting at each offset. The i-th hash corresponds to the kmer starting at position i in the sequence. </dd></dl>

</div>
</div>
<a id="a599a31577c9216f1e8e3338bae26da07" name="a599a31577c9216f1e8e3338bae26da07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599a31577c9216f1e8e3338bae26da07">&#9670;&#160;</a></span>hash_kmer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; ngsai::dna::hash_kmer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the hash each kmer (at every offset) in the sequence using a Rabin-Karp rolling hash implementation. The hash represents the index at which the kmers would be located if all possible kmers with this length were sorted. This function is designed for fixed length kmers. The hashes of kmers of different lengths should not be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence of interest. </td></tr>
    <tr><td class="paramname">kmer_size</td><td>the size of the kmer to hash from the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence is too short to contain the given kmer or if it contains an invalid DNA character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the hashes of each kmer, starting at each offset. The i-th hash corresponds to the kmer starting at position i in the sequence. </dd></dl>

</div>
</div>
<a id="acc505e91b9257703455215130e5f2df9" name="acc505e91b9257703455215130e5f2df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc505e91b9257703455215130e5f2df9">&#9670;&#160;</a></span>hash_kmer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ngsai::dna::hash_kmer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a hash for the sub-sequence starting at the given position in the sequence and of the given length. The hash represents the index at which the sub-sequence would be located if all possible sequences of the same length were sorted. This function is designed for fixed length sequences. The hashes of sequences of different lengths should not be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequencee containing the sub-sequence of interest. </td></tr>
    <tr><td class="paramname">start</td><td>the 0 based position at which the sub-sequence starts in the sequence. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the sub-sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence is too short to contain the given kmer or if it contains an invalid DNA character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kmer hash. </dd></dl>

</div>
</div>
<a id="ace82f34150416da314e1dbbc1f9aa540" name="ace82f34150416da314e1dbbc1f9aa540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace82f34150416da314e1dbbc1f9aa540">&#9670;&#160;</a></span>hash_kmer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; ngsai::dna::hash_kmer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>kmer_sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the hash each kmer (at every offset) in the sequence using a Rabin-Karp rolling hash implementation. The kmer hashes are returned and the kmer sequences are stored in the given vector. The hash represents the index at which the kmers would be located if all possible kmers with this length were sorted. This function is designed for fixed length kmers. The hashes of kmers of different lengths should not be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence of interest. </td></tr>
    <tr><td class="paramname">kmer_size</td><td>the size of the kmer to hash from the sequence. </td></tr>
    <tr><td class="paramname">kmer_sequences</td><td>a vector in which each kmer sequence will be stored. The sequence order will match the hash order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sequence is too short to contain the given kmer or if it contains an invalid DNA character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the hashes of each kmer, starting at each offset. The i-th hash corresponds to the kmer starting at position i in the sequence. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a40371e0fb437e53989372541555323c7" name="a40371e0fb437e53989372541555323c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40371e0fb437e53989372541555323c7">&#9670;&#160;</a></span>dna_alphabet_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ngsai::dna::dna_alphabet_size = base_code.size()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the DNA character set. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
