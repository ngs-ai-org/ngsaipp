<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ngsaipp: ngsai Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ngsaipp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ngsai Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains values that are useful for formatting terminal output.  
<a href="namespacengsai.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacengsai_1_1algorithms"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1algorithms.html">algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacengsai_1_1dna"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1dna.html">dna</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacengsai_1_1genome"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai_1_1genome.html">genome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1BedReader.html">BedReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to perform sequencial reading from a BED file using the <a class="el" href="classngsai_1_1BedReader.html#a8b5cfe6bdb68efacd467698896f850d4" title="Reads the next record in the file.">getNext()</a> method. Currently BED 6 format is handled.  <a href="classngsai_1_1BedReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1BedRecord.html">BedRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1CcsKineticExtractor.html">CcsKineticExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1CcsKineticExtractor.html" title="The CcsKineticExtractor allows to extract inter pulse durations (IPDs) and pulse widths (PWDs) in giv...">CcsKineticExtractor</a> allows to extract inter pulse durations (IPDs) and pulse widths (PWDs) in given region from mapped PacBio CCSs. The region are always specified in reference coordinates (the reference onto which the CCS is mapped). The window specifies a region, on one of the reference strands, as a semi open interval [from, to). Then, if the CCS maps over this reference region, the CCS sequence, IPDs and PWDs values corresponding to the window are extracted. The sequence, IPDs and PWDs are always returned in 5' to 3' order with respect to the window strand (that is on the reference).  <a href="classngsai_1_1CcsKineticExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1DiPositionKineticModel.html">DiPositionKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1DiPositionKineticModel.html" title="The DiPositionKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">DiPositionKineticModel</a> class is made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model is a special case of the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a>. The <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> accounted for all N = ((L*L) - L) / 2 pair-wise position interaction whereas this one only considers L-1 interactions between any two directly neighbouring positions in the window. Except for this, everything is the same as in <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a>.  <a href="classngsai_1_1DiPositionKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1DiPositionNormalizedKineticModel.html">DiPositionNormalizedKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1DiPositionNormalizedKineticModel.html" title="The DiPositionNormalizedKineticModel class is made to model the normalized IPD and PWD signal from Pa...">DiPositionNormalizedKineticModel</a> class is made to model the normalized IPD and PWD signal from PacBio CCS. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1DiPositionKineticModel.html" title="The DiPositionKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">DiPositionKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model is a special case of the <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a>. The <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a> accounted for all N = ((L*L) - L) / 2 <br  />
 pair-wise position interaction whereas this one only considers L-1 interactions between any two directly neighbouring positions in the window. Except for this, everything is the same as in <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a>.  <a href="classngsai_1_1DiPositionNormalizedKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1KineticClassifier.html">KineticClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1KineticModel.html">KineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a> class is an abstract class providing an interface to derive for classes that implement a statistical model of the kinetic signal of PacBio CCSs.  <a href="classngsai_1_1KineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1KineticSignal.html">KineticSignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="classngsai_1_1KineticSignal.html" title="the KineticSignal class is designed to be a data structure to store the DNA sequence and kinetic - IP...">KineticSignal</a> class is designed to be a data structure to store the DNA sequence and kinetic - IPD and PWD - information in a given strech of DNA. An instance has a size, that is the length of the DNA strech, in bp, that is modelled. The default contructor allow to create empy - 0bp - streches and to add data later using the setter methods. In this case, the size is set at the 1st use of a setter. Except this 1st insertion - on an empty instance - data inserted must have the same size as the instance.  <a href="classngsai_1_1KineticSignal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1KmerData.html">KmerData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1KmerData.html" title="The KmerData class is a class allowing to model a kmer together with per sequence position IPD and PW...">KmerData</a> class is a class allowing to model a kmer together with per sequence position IPD and PWD data. Each of the sequence position corresponds to the same data vector index.  <a href="classngsai_1_1KmerData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1KmerMap.html">KmerMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1KmerMap.html" title="The KmerMap is a template class allowing to create a map storing per kmer kinetic information....">KmerMap</a> is a template class allowing to create a map storing per kmer kinetic information. It is designed to allow O(k) insertion and O(1) query operations using a Rabin-Karp hashing approach. Each kmer is kinetic information is stored in a pair, together with the number of insertions in the map made for the corresponding kmer. The memory footprint of the map is N**k where N is the number of character in the alphabet - the alphabet is defined in ngsai::base_code in <a class="el" href="dna__utility_8hpp.html">dna/dna_utility.hpp</a>) - and k is the kmer size.  <a href="classngsai_1_1KmerMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1NormalizedKineticModel.html">NormalizedKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1NormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">NormalizedKineticModel</a> class is made to model the IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. In the end, as for the <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> class, the signal models contains 2*L different distributions of signal. The distributions at each position are empiric and are made of 2*L histograms h_ipd(1), h_pwd(1), h_ipd(2), h_pwd(2) ..., h_ipd(L), h_pwd(L). The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL corresponding to a DNA sequence S s1, s2, ..., sL, each value xi and yi will be normalized into n(xi) n(yi) using a normalizing function accounting for the sequence context S. Then each histogram h_ipd(i) and h_pwd(i) will be added a count corresponding to the value n(xi) an n(yi) respectively. h_ipd(1) will be added a count corresponding to n(x1), h_ipd(2) will be added a count corresponding to n(x2), ..., h_ipd(L) will be added a count corresponding to n(xL). The same will apply for the PWD histograms with normalized Y values. Once the histograms have been filled, the model can be normalized in order to transform the 2*L histograms into 2*L probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL corresponding to a sequence S s1, s2, ..., sL. The likelihood corresponds to : p(n(x1) | h_ipd(1)) * p(n(y1) | h_pwd(1)) *... * p(n(xL) | h_ipd(L)) * p(n(xL) | h_pwd(L)) where p(n(xi) | h(i)) means the probability of observing the normalized value n(x) at the i-th position of the window, according to the density modeled in the histogram h(i).  <a href="classngsai_1_1NormalizedKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1PairWiseKineticModel.html">PairWiseKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> class is made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model accounts for pair-wise relaitions ships between any two positions in the window. There are exactly N = ((L*L) - L) / 2 pair-wise relations. The signal in the Lbp window is modelled using 2*N different distributions of signal - N for IPD and N for PWD signal. Each distribution is modelled by a 2D histogram representing the signal at one position p in the window with respect to the signal found at the paired position q in the window where p != q. Overall the window signal is modelled by 2*N histograms h_ipd_p_q and h_pwd_p_q : h_ipd_1_2, h_ipd_1_3, ..., h_ipd_1_L, h_ipd_2_3, ..., h_ipd_2_L, ..., h_ipd_L-1_L and h_pwd_1_2, h_pwd_1_3, ..., h_pwd_1_L, h_pwd_2_3, ..., h_pwd_2_L, ..., h_pwd_L-1_L. The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each pair of positions in the window. At this moment, the histograms are count histograms. Once the histograms have been filled, the model can be normalized in order to transform the 2*N histograms into 2*N probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL. The likelihood corresponds to : p(x1,x2 | h_ipd_1_2) * p(x1,x3 | h_ipd_1_3) *... * p(x1,xL | h_ipd_1_L)  <a href="classngsai_1_1PairWiseKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html">PairWiseNormalizedKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1NormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">NormalizedKineticModel</a> class is made to model the IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. In the end, as for the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> class, the signal models contains 2*N different distributions of signal modelling all possible N = ((L*L) - L) / 2 pair-wise position relation between any position p and q where p != q : h_ipd_1_2, h_ipd_1_3, ..., h_ipd_1_L, h_ipd_2_3, ..., h_ipd_2_L, ..., h_ipd_L-1_L and h_pwd_1_2, h_pwd_1_3, ..., h_pwd_1_L, h_pwd_2_3, ..., h_pwd_2_L, ..., h_pwd_L-1_L. The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL corresponding to a DNA sequence S s1, s2, ..., sL, each value xi and yi will be normalized into n(xi) n(yi) using a normalizing function accounting for the sequence context S. Then each histogram h_ipd_p_q and h_pwd_p_q will be added a count corresponding to the pairs of values n(xp), n(xq) an n(yp), n(yq) respectively. Once the histograms have been filled, the model can be normalized in order to transform the 2*N histograms into 2*N probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL corresponding to a sequence S s1, s2, ..., sL. The likelihood corresponds to : p(n(x1),n(x2) | h_ipd_1_2) * p(n(x1),n(x3) | h_ipd_1_3) *... * p(n(x1),n(xL) | h_ipd_1_L) * p(n(x2),n(x3) | h_ipd_2_3) * ... * p(n(x2),n(xL) | h_ipd_2_L) * ... * p(n(xL-1),n(xL) | h_ipd_L-1_L) * p(n(y1),n(y2) | h_pwd_1_2) * p(n(y1),n(y3) | h_pwd_1_3) * ... * p(n(y1),n(yL) | h_pwd_1_L) * p(n(y2),n(y3) | h_pwd_2_3) * ... * p(n(y2),n(yL) | h_pwd_2_L) * ... * p(n(yL-1),n(yL) | h_pwd_L-1_L) where p(n(xp), n(xq) | h_p_q) means the probability of observing the normalized value n(xp) at the position p and n(xq) at position q of the window, according to the density modeled in the histogram h_p_q.  <a href="classngsai_1_1PairWiseNormalizedKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1RawKineticModel.html">RawKineticModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> class is made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. The signal in the Lbp window is modelled using 2*L different distributions of signal - L for IPD and L for PWD signal. The distributions at each position are empiric. Overall the window signal is modelled by 2*L histograms h_ipd(1), h_ipd(2), ..., h_ipd(L) and h_pwd(1), h_pwd(2), ..., h_pwd(L). The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. At this moment, the histograms are count histograms. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL then each histogram h_ipd(i) and h_pwd(i) will be added a count corresponding to the value xi an yi respectively. h_ipd(1) will be added a count corresponding to x1, h_ipd(2) will be added a count corresponding to x2, ..., h_ipd(L) will be added a count corresponding to xL. The same will apply for the PWD histograms with Y values. Once the histograms have been filled, the model can be normalized in order to transform the 2*L histograms into 2*L probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL. The likelihood corresponds to : p(x1 | h_ipd(1)) * p(y1 | h_pwd(1)) *... * p(xL | h_ipd(L)) * p(xL | h_pwd(L)) where p(xi | h(i)) means the probability of observing the value x at the i-th position of the window, according to the density modeled in the histogram h(i).  <a href="classngsai_1_1RawKineticModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classngsai_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classngsai_1_1ThreadPool.html" title="The ThreadPool class implements a simple pool of working threads. At construction,...">ThreadPool</a> class implements a simple pool of working threads. At construction, &lt;n&gt; threads are spawned and tries to get tasks to execute from a queue. Any access to the queue is synchonized through the use of a mutex. Jobs are added to the queue by calling addJob(task) where task is the result of std::bind(). The queue can be open - in which case the jobs are effectively added to the queues - or closed - in which case nothing can be push into the queue anymore. Stopping the pool is done through calling <a class="el" href="classngsai_1_1ThreadPool.html#a2a8767845dcae378ce14975251bbb458" title="closes the job queues and join the threads. When this methods returns, all the jobs have been run and...">join()</a> which will close the queue.  <a href="classngsai_1_1ThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab667af3aa89fb3a9acdbda7a75805a2b"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; uint32_t, <a class="el" href="classngsai_1_1KmerData.html">ngsai::KmerData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ab667af3aa89fb3a9acdbda7a75805a2b">kmerBucket</a></td></tr>
<tr class="separator:ab667af3aa89fb3a9acdbda7a75805a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2367cd49ed6131b42b0726ce77529a67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67">bool_ext</a> { <a class="el" href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67af30668ea62b92f02b33a8a60ffa912f8">False</a> =0
, <a class="el" href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67a6bd655099213c295956e6ca59a5c02ab">True</a> =1
, <a class="el" href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67af2aa4a5dc4be6b60f12c15a0e7931f69">Undefined</a> =2
 }</td></tr>
<tr class="memdesc:a2367cd49ed6131b42b0726ce77529a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends boolean with an undefined value.  <a href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67">More...</a><br /></td></tr>
<tr class="separator:a2367cd49ed6131b42b0726ce77529a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac607047bf3e626ec725c799038d3ead8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ac607047bf3e626ec725c799038d3ead8">normalize_kinetics</a> (const std::string &amp;seq, const std::vector&lt; double &gt; &amp;ipd, const std::vector&lt; double &gt; &amp;pwd, const <a class="el" href="classngsai_1_1KmerMap.html">ngsai::KmerMap</a> &amp;model)</td></tr>
<tr class="memdesc:ac607047bf3e626ec725c799038d3ead8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the raw kinetic signal by the mean signal expected from its sequence context. Note that the normalization process can only produce a value for the central values of the vectors. The first K/2 and last K/2 values - where K is the size of the kmer inside the model - will be dropped.  <br /></td></tr>
<tr class="separator:ac607047bf3e626ec725c799038d3ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed30e8a4d63c9d38fb4b784522f9bb6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aeed30e8a4d63c9d38fb4b784522f9bb6">normalize_kinetics</a> (const std::string &amp;seq, const std::vector&lt; uint16_t &gt; &amp;ipd, const std::vector&lt; uint16_t &gt; &amp;pwd, const <a class="el" href="classngsai_1_1KmerMap.html">ngsai::KmerMap</a> &amp;model)</td></tr>
<tr class="memdesc:aeed30e8a4d63c9d38fb4b784522f9bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the raw kinetic signal by the mean signal expected from its sequence context. Note that the normalization process can only produce a value for the central values of the vectors. The first K/2 and last K/2 values - where K is the size of the kmer inside the model - will be dropped.  <br /></td></tr>
<tr class="separator:aeed30e8a4d63c9d38fb4b784522f9bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ef8c0eeefbc574946219066efae383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#af6ef8c0eeefbc574946219066efae383">train_KineticModel</a> (<a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *model, const std::vector&lt; <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &gt; &amp;regions, size_t regions_from, size_t regions_to, const std::vector&lt; std::string &gt; &amp;paths_bam)</td></tr>
<tr class="memdesc:af6ef8c0eeefbc574946219066efae383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed as <a class="el" href="classngsai_1_1BedRecord.html">BedRecord</a>. The model is trained on the subset of regions [regions_from,region_to). For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model.  <br /></td></tr>
<tr class="separator:af6ef8c0eeefbc574946219066efae383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61804df9e9090bba410569ac78ec2527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a61804df9e9090bba410569ac78ec2527">train_KineticModel</a> (<a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *model, const std::vector&lt; <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &gt; &amp;regions, const std::vector&lt; std::string &gt; &amp;paths_bam)</td></tr>
<tr class="memdesc:a61804df9e9090bba410569ac78ec2527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed as <a class="el" href="classngsai_1_1BedRecord.html">BedRecord</a>. For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model.  <br /></td></tr>
<tr class="separator:a61804df9e9090bba410569ac78ec2527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f5f7001d1ed60680906c0de452c6f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a36f5f7001d1ed60680906c0de452c6f0">train_KineticModel</a> (<a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *model, const std::string &amp;path_bed, const std::vector&lt; std::string &gt; &amp;paths_bam)</td></tr>
<tr class="memdesc:a36f5f7001d1ed60680906c0de452c6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed in the BED file. For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model.  <br /></td></tr>
<tr class="separator:a36f5f7001d1ed60680906c0de452c6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9430bba3ccc4233ea811faf138635cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ab9430bba3ccc4233ea811faf138635cf">hist2d_to_matrix</a> (const <a class="el" href="PairWiseKineticModel_8hpp.html#a47a41088956c306e6acdc3d173959fcf">hist_2d_double</a> &amp;h)</td></tr>
<tr class="memdesc:ab9430bba3ccc4233ea811faf138635cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the content of a 2D histogram into a matrix. The first dimension of the matrix represents the 1st axis and the 2nd dimension the 2nd axis. The histogram bins going to -inf and +inf are also put in the matrix (first and last on both dimensions).  <br /></td></tr>
<tr class="separator:ab9430bba3ccc4233ea811faf138635cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d639ede3ea1dcf107e9cf867dc8d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#af66d639ede3ea1dcf107e9cf867dc8d2">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classngsai_1_1RawKineticModel.html">ngsai::RawKineticModel</a> &amp;model)</td></tr>
<tr class="memdesc:af66d639ede3ea1dcf107e9cf867dc8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> to the output stream. Does nothing if the model is not initialized.  <br /></td></tr>
<tr class="separator:af66d639ede3ea1dcf107e9cf867dc8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e31f00b216545c4f838cf3c3abb1917"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a0e31f00b216545c4f838cf3c3abb1917">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &amp;record)</td></tr>
<tr class="memdesc:a0e31f00b216545c4f838cf3c3abb1917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given record to a stream.  <br /></td></tr>
<tr class="separator:a0e31f00b216545c4f838cf3c3abb1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f022b45f71e8ac2178be7c7b2bfbf10"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a3f022b45f71e8ac2178be7c7b2bfbf10">split</a> (const std::string &amp;s, char separator)</td></tr>
<tr class="memdesc:a3f022b45f71e8ac2178be7c7b2bfbf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the string into substrings according to the given separator.  <br /></td></tr>
<tr class="separator:a3f022b45f71e8ac2178be7c7b2bfbf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30ba1f2b94c85ffbb8300dd314af3f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ae30ba1f2b94c85ffbb8300dd314af3f9">endswith</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ae30ba1f2b94c85ffbb8300dd314af3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether str ends with the given suffix.  <br /></td></tr>
<tr class="separator:ae30ba1f2b94c85ffbb8300dd314af3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0e620c7114f1dfd1fed11f80679a3bd5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a0e620c7114f1dfd1fed11f80679a3bd5">CEND</a> = &quot;\33[0m&quot;</td></tr>
<tr class="separator:a0e620c7114f1dfd1fed11f80679a3bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf508c488d8faa707ffb113dd5417f45"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aaf508c488d8faa707ffb113dd5417f45">CBOLD</a> = &quot;\33[1m&quot;</td></tr>
<tr class="separator:aaf508c488d8faa707ffb113dd5417f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93000e1590d237479ca68d52275b8f00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a93000e1590d237479ca68d52275b8f00">CITALIC</a> = &quot;\33[3m&quot;</td></tr>
<tr class="separator:a93000e1590d237479ca68d52275b8f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accffe48aa21e767df16d7d04c57513e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#accffe48aa21e767df16d7d04c57513e4">CURL</a> = &quot;\33[4m&quot;</td></tr>
<tr class="separator:accffe48aa21e767df16d7d04c57513e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b592da02899964123e6f441105ee7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a353b592da02899964123e6f441105ee7">CBLINK</a> = &quot;\33[5m&quot;</td></tr>
<tr class="separator:a353b592da02899964123e6f441105ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d6ab6699c80ef005d0bccf4aae0bac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a67d6ab6699c80ef005d0bccf4aae0bac">CBLINK2</a> = &quot;\33[6m&quot;</td></tr>
<tr class="separator:a67d6ab6699c80ef005d0bccf4aae0bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d9b77583da1d03bd827f33c2c0597"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#afa2d9b77583da1d03bd827f33c2c0597">CSELECTED</a> = &quot;\33[7m&quot;</td></tr>
<tr class="separator:afa2d9b77583da1d03bd827f33c2c0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c98f1d7f542e5196f9e48b463dd21d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a98c98f1d7f542e5196f9e48b463dd21d">CBLACK</a> = &quot;\33[30m&quot;</td></tr>
<tr class="separator:a98c98f1d7f542e5196f9e48b463dd21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193e8d7511582417e7f99828ddac9d73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a193e8d7511582417e7f99828ddac9d73">CRED</a> = &quot;\33[31m&quot;</td></tr>
<tr class="separator:a193e8d7511582417e7f99828ddac9d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e16821b33c7b74208c095a576bd8ad3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a5e16821b33c7b74208c095a576bd8ad3">CGREEN</a> = &quot;\33[32m&quot;</td></tr>
<tr class="separator:a5e16821b33c7b74208c095a576bd8ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f00ea7467734b48c32ff7d6c2e1994"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ad1f00ea7467734b48c32ff7d6c2e1994">CYELLOW</a> = &quot;\33[33m&quot;</td></tr>
<tr class="separator:ad1f00ea7467734b48c32ff7d6c2e1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57585ec3143257e6bf91d9a74f85f919"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a57585ec3143257e6bf91d9a74f85f919">CBLUE</a> = &quot;\33[34m&quot;</td></tr>
<tr class="separator:a57585ec3143257e6bf91d9a74f85f919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e540a0afc131cc17da0809e30741a9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#ae8e540a0afc131cc17da0809e30741a9">CVIOLET</a> = &quot;\33[35m&quot;</td></tr>
<tr class="separator:ae8e540a0afc131cc17da0809e30741a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7603a6956b2db1c483f221b6f9036f72"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a7603a6956b2db1c483f221b6f9036f72">CBEIGE</a> = &quot;\33[36m&quot;</td></tr>
<tr class="separator:a7603a6956b2db1c483f221b6f9036f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6616239d8e504201721ba2f5d16dac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aae6616239d8e504201721ba2f5d16dac">CWHITE</a> = &quot;\33[37m&quot;</td></tr>
<tr class="separator:aae6616239d8e504201721ba2f5d16dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cce422ee5235f0d2131d3e0359554d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a91cce422ee5235f0d2131d3e0359554d">CBLACKBG</a> = &quot;\33[40m&quot;</td></tr>
<tr class="separator:a91cce422ee5235f0d2131d3e0359554d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd3e5dcf412c24c98e8dc21f1c4dfd4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aabd3e5dcf412c24c98e8dc21f1c4dfd4">CREDBG</a> = &quot;\33[41m&quot;</td></tr>
<tr class="separator:aabd3e5dcf412c24c98e8dc21f1c4dfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488937a7ea9a648694249faba6e47973"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a488937a7ea9a648694249faba6e47973">CGREENBG</a> = &quot;\33[42m&quot;</td></tr>
<tr class="separator:a488937a7ea9a648694249faba6e47973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685afefc081332084e1a6f273e11fc9d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a685afefc081332084e1a6f273e11fc9d">CYELLOWBG</a> = &quot;\33[43m&quot;</td></tr>
<tr class="separator:a685afefc081332084e1a6f273e11fc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c7f2d0c8de956afe519233f7b19ffc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a19c7f2d0c8de956afe519233f7b19ffc">CBLUEBG</a> = &quot;\33[44m&quot;</td></tr>
<tr class="separator:a19c7f2d0c8de956afe519233f7b19ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bd82c3c6fc87d493bf4af34229d407"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a48bd82c3c6fc87d493bf4af34229d407">CVIOLETBG</a> = &quot;\33[45m&quot;</td></tr>
<tr class="separator:a48bd82c3c6fc87d493bf4af34229d407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc88932462d2395829912da588eb645f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#afc88932462d2395829912da588eb645f">CBEIGEBG</a> = &quot;\33[46m&quot;</td></tr>
<tr class="separator:afc88932462d2395829912da588eb645f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3ed88e736851042b37336aa1f2882d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a7b3ed88e736851042b37336aa1f2882d">CWHITEBG</a> = &quot;\33[47m&quot;</td></tr>
<tr class="separator:a7b3ed88e736851042b37336aa1f2882d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a72ef48677b75c8f3338ef76f3943"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a536a72ef48677b75c8f3338ef76f3943">CGREY</a> = &quot;\33[90m&quot;</td></tr>
<tr class="separator:a536a72ef48677b75c8f3338ef76f3943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb055ad1d5f9a34a86bc19fb3cf7f16"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a5fb055ad1d5f9a34a86bc19fb3cf7f16">CRED2</a> = &quot;\33[91m&quot;</td></tr>
<tr class="separator:a5fb055ad1d5f9a34a86bc19fb3cf7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b348aa1c52545134581468f5c55453"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aa9b348aa1c52545134581468f5c55453">CGREEN2</a> = &quot;\33[92m&quot;</td></tr>
<tr class="separator:aa9b348aa1c52545134581468f5c55453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66bf09702cf1b81d8bf2f95487f3270"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#af66bf09702cf1b81d8bf2f95487f3270">CYELLOW2</a> = &quot;\33[93m&quot;</td></tr>
<tr class="separator:af66bf09702cf1b81d8bf2f95487f3270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3757ad7d51e06230eacefb85dfcfdc48"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a3757ad7d51e06230eacefb85dfcfdc48">CBLUE2</a> = &quot;\33[94m&quot;</td></tr>
<tr class="separator:a3757ad7d51e06230eacefb85dfcfdc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a811764f322b39c941da90743b82cf6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a0a811764f322b39c941da90743b82cf6">CVIOLET2</a> = &quot;\33[95m&quot;</td></tr>
<tr class="separator:a0a811764f322b39c941da90743b82cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1227a26103735dbcfa743a7cdbcd62"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a7e1227a26103735dbcfa743a7cdbcd62">CBEIGE2</a> = &quot;\33[96m&quot;</td></tr>
<tr class="separator:a7e1227a26103735dbcfa743a7cdbcd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffcccd2c4dc78323af7535995baa9d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a1ffcccd2c4dc78323af7535995baa9d9">CWHITE2</a> = &quot;\33[97m&quot;</td></tr>
<tr class="separator:a1ffcccd2c4dc78323af7535995baa9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dad75e44f5a74c0e563d71aaab0220c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a7dad75e44f5a74c0e563d71aaab0220c">CGREYBG</a> = &quot;\33[100m&quot;</td></tr>
<tr class="separator:a7dad75e44f5a74c0e563d71aaab0220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af5d676084ffe2332eede66a0aa1433"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a3af5d676084ffe2332eede66a0aa1433">CREDBG2</a> = &quot;\33[101m&quot;</td></tr>
<tr class="separator:a3af5d676084ffe2332eede66a0aa1433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded334b5fd89b062c6564c31123541b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a2ded334b5fd89b062c6564c31123541b">CGREENBG2</a> = &quot;\33[102m&quot;</td></tr>
<tr class="separator:a2ded334b5fd89b062c6564c31123541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc28aee581d3a16d682108f55b679c24"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#abc28aee581d3a16d682108f55b679c24">CYELLOWBG2</a> = &quot;\33[103m&quot;</td></tr>
<tr class="separator:abc28aee581d3a16d682108f55b679c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9e9a21b7474fbc5196e5c20ef2dcb7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#aed9e9a21b7474fbc5196e5c20ef2dcb7">CBLUEBG2</a> = &quot;\33[104m&quot;</td></tr>
<tr class="separator:aed9e9a21b7474fbc5196e5c20ef2dcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d1f1a1cc432e01a10967c38bfefc7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a810d1f1a1cc432e01a10967c38bfefc7">CVIOLETBG2</a> = &quot;\33[105m&quot;</td></tr>
<tr class="separator:a810d1f1a1cc432e01a10967c38bfefc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc3313b0c45c915d75311df9875eb6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a69cc3313b0c45c915d75311df9875eb6">CBEIGEBG2</a> = &quot;\33[106m&quot;</td></tr>
<tr class="separator:a69cc3313b0c45c915d75311df9875eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b572fed734f2da103923fb8806e4e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacengsai.html#a353b572fed734f2da103923fb8806e4e">CWHITEBG2</a> = &quot;\33[107m&quot;</td></tr>
<tr class="separator:a353b572fed734f2da103923fb8806e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains values that are useful for formatting terminal output. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab667af3aa89fb3a9acdbda7a75805a2b" name="ab667af3aa89fb3a9acdbda7a75805a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667af3aa89fb3a9acdbda7a75805a2b">&#9670;&#160;</a></span>kmerBucket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;uint32_t,<a class="el" href="classngsai_1_1KmerData.html">ngsai::KmerData</a>&gt; <a class="el" href="namespacengsai.html#ab667af3aa89fb3a9acdbda7a75805a2b">ngsai::kmerBucket</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2367cd49ed6131b42b0726ce77529a67" name="a2367cd49ed6131b42b0726ce77529a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2367cd49ed6131b42b0726ce77529a67">&#9670;&#160;</a></span>bool_ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacengsai.html#a2367cd49ed6131b42b0726ce77529a67">ngsai::bool_ext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends boolean with an undefined value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2367cd49ed6131b42b0726ce77529a67af30668ea62b92f02b33a8a60ffa912f8" name="a2367cd49ed6131b42b0726ce77529a67af30668ea62b92f02b33a8a60ffa912f8"></a>False&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2367cd49ed6131b42b0726ce77529a67a6bd655099213c295956e6ca59a5c02ab" name="a2367cd49ed6131b42b0726ce77529a67a6bd655099213c295956e6ca59a5c02ab"></a>True&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2367cd49ed6131b42b0726ce77529a67af2aa4a5dc4be6b60f12c15a0e7931f69" name="a2367cd49ed6131b42b0726ce77529a67af2aa4a5dc4be6b60f12c15a0e7931f69"></a>Undefined&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae30ba1f2b94c85ffbb8300dd314af3f9" name="ae30ba1f2b94c85ffbb8300dd314af3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30ba1f2b94c85ffbb8300dd314af3f9">&#9670;&#160;</a></span>endswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ngsai::endswith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether str ends with the given suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string of interest. </td></tr>
    <tr><td class="paramname">suffix</td><td>the suffix of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether str ends with suffix. </dd></dl>

</div>
</div>
<a id="ab9430bba3ccc4233ea811faf138635cf" name="ab9430bba3ccc4233ea811faf138635cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9430bba3ccc4233ea811faf138635cf">&#9670;&#160;</a></span>hist2d_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; ngsai::hist2d_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="PairWiseKineticModel_8hpp.html#a47a41088956c306e6acdc3d173959fcf">hist_2d_double</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the content of a 2D histogram into a matrix. The first dimension of the matrix represents the 1st axis and the 2nd dimension the 2nd axis. The histogram bins going to -inf and +inf are also put in the matrix (first and last on both dimensions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the histogram of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix representation of the histogram. </dd></dl>

</div>
</div>
<a id="ac607047bf3e626ec725c799038d3ead8" name="ac607047bf3e626ec725c799038d3ead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac607047bf3e626ec725c799038d3ead8">&#9670;&#160;</a></span>normalize_kinetics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; ngsai::normalize_kinetics </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ipd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classngsai_1_1KmerMap.html">ngsai::KmerMap</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the raw kinetic signal by the mean signal expected from its sequence context. Note that the normalization process can only produce a value for the central values of the vectors. The first K/2 and last K/2 values - where K is the size of the kmer inside the model - will be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence from which the kinetics were taken, </td></tr>
    <tr><td class="paramname">ipd</td><td>the raw IPDs corresponding to each base of the sequence. </td></tr>
    <tr><td class="paramname">pwd</td><td>the raw PWDs corresponding to each base of the sequence. </td></tr>
    <tr><td class="paramname">model</td><td>a map containing the mean expected signal for each possible kmer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the kinetics and sequence size don't match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the normalized IPD (first) and PWD (second) values. </dd></dl>

</div>
</div>
<a id="aeed30e8a4d63c9d38fb4b784522f9bb6" name="aeed30e8a4d63c9d38fb4b784522f9bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed30e8a4d63c9d38fb4b784522f9bb6">&#9670;&#160;</a></span>normalize_kinetics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; ngsai::normalize_kinetics </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ipd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classngsai_1_1KmerMap.html">ngsai::KmerMap</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the raw kinetic signal by the mean signal expected from its sequence context. Note that the normalization process can only produce a value for the central values of the vectors. The first K/2 and last K/2 values - where K is the size of the kmer inside the model - will be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence from which the kinetics were taken, </td></tr>
    <tr><td class="paramname">ipd</td><td>the raw IPDs corresponding to each base of the sequence. </td></tr>
    <tr><td class="paramname">pwd</td><td>the raw PWDs corresponding to each base of the sequence. </td></tr>
    <tr><td class="paramname">model</td><td>a map containing the mean expected signal for each possible kmer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the kinetics and sequence size don't match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the normalized IPD (first) and PWD (second) values. </dd></dl>

</div>
</div>
<a id="a0e31f00b216545c4f838cf3c3abb1917" name="a0e31f00b216545c4f838cf3c3abb1917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e31f00b216545c4f838cf3c3abb1917">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ngsai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given record to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the stream to write the record to. </td></tr>
    <tr><td class="paramname">record</td><td>the record to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream after the writing. </dd></dl>

</div>
</div>
<a id="af66d639ede3ea1dcf107e9cf867dc8d2" name="af66d639ede3ea1dcf107e9cf867dc8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66d639ede3ea1dcf107e9cf867dc8d2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ngsai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classngsai_1_1RawKineticModel.html">ngsai::RawKineticModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> to the output stream. Does nothing if the model is not initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>an output stream to write to. </td></tr>
    <tr><td class="paramname">model</td><td>a model of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the output stream the model was written to. </dd></dl>

</div>
</div>
<a id="a3f022b45f71e8ac2178be7c7b2bfbf10" name="a3f022b45f71e8ac2178be7c7b2bfbf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f022b45f71e8ac2178be7c7b2bfbf10">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; ngsai::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the string into substrings according to the given separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>the string to split. </td></tr>
    <tr><td class="paramname">separator</td><td>the separator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the substrings. </dd></dl>

</div>
</div>
<a id="a36f5f7001d1ed60680906c0de452c6f0" name="a36f5f7001d1ed60680906c0de452c6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f5f7001d1ed60680906c0de452c6f0">&#9670;&#160;</a></span>train_KineticModel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ngsai::train_KineticModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_bed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_bam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed in the BED file. For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>a pointer to the kinetic model to train. This model must have been already initialised using setParameters(). </td></tr>
    <tr><td class="paramname">path_bed</td><td>the path to the bed file containing the CpG coordinates from which the signal must be learnt. </td></tr>
    <tr><td class="paramname">paths_bam</td><td>the paths to the bam files containing the <br  />
 mapped CCS from which the signal must be extracted to learn the models. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the model was not yet initialised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61804df9e9090bba410569ac78ec2527" name="a61804df9e9090bba410569ac78ec2527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61804df9e9090bba410569ac78ec2527">&#9670;&#160;</a></span>train_KineticModel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ngsai::train_KineticModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_bam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed as <a class="el" href="classngsai_1_1BedRecord.html">BedRecord</a>. For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>a pointer to the kinetic model to train. This model must have been already initialised using setParameters(). </td></tr>
    <tr><td class="paramname">region</td><td>a list of genomic regions containing the CpG coordinates from which the signal must be learnt. </td></tr>
    <tr><td class="paramname">paths_bam</td><td>the paths to the bam files containing the <br  />
 mapped CCS from which the signal must be extracted to learn the models. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the model was not yet initialised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ef8c0eeefbc574946219066efae383" name="af6ef8c0eeefbc574946219066efae383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ef8c0eeefbc574946219066efae383">&#9670;&#160;</a></span>train_KineticModel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ngsai::train_KineticModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classngsai_1_1KineticModel.html">ngsai::KineticModel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classngsai_1_1BedRecord.html">ngsai::BedRecord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>regions_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>regions_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_bam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trains a <a class="el" href="classngsai_1_1KineticModel.html" title="The KineticModel class is an abstract class providing an interface to derive for classes that impleme...">KineticModel</a>, from the CCS overlapping the genomic windows listed as <a class="el" href="classngsai_1_1BedRecord.html">BedRecord</a>. The model is trained on the subset of regions [regions_from,region_to). For each CpG listed, the mean IPD and PWD values at each position within the window (defined in model) are computed from all CCS aligning at this position. The mean IPD and PWD values are then introduced in the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>a pointer to the kinetic model to train. This model must have been already initialised using setParameters(). </td></tr>
    <tr><td class="paramname">region</td><td>a list of genomic regions containing the CpG coordinates from which the signal must be learnt. </td></tr>
    <tr><td class="paramname">regions_from</td><td>the index of the 1st region to use for training in the vector of regions. </td></tr>
    <tr><td class="paramname">regions</td><td>the index of the past the last region to use for training in the vector of regions. </td></tr>
    <tr><td class="paramname">paths_bam</td><td>the paths to the bam files containing the <br  />
 mapped CCS from which the signal must be extracted to learn the models. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the model was not yet initialised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7603a6956b2db1c483f221b6f9036f72" name="a7603a6956b2db1c483f221b6f9036f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7603a6956b2db1c483f221b6f9036f72">&#9670;&#160;</a></span>CBEIGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBEIGE = &quot;\33[36m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e1227a26103735dbcfa743a7cdbcd62" name="a7e1227a26103735dbcfa743a7cdbcd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1227a26103735dbcfa743a7cdbcd62">&#9670;&#160;</a></span>CBEIGE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBEIGE2 = &quot;\33[96m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc88932462d2395829912da588eb645f" name="afc88932462d2395829912da588eb645f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc88932462d2395829912da588eb645f">&#9670;&#160;</a></span>CBEIGEBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBEIGEBG = &quot;\33[46m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69cc3313b0c45c915d75311df9875eb6" name="a69cc3313b0c45c915d75311df9875eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc3313b0c45c915d75311df9875eb6">&#9670;&#160;</a></span>CBEIGEBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBEIGEBG2 = &quot;\33[106m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98c98f1d7f542e5196f9e48b463dd21d" name="a98c98f1d7f542e5196f9e48b463dd21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c98f1d7f542e5196f9e48b463dd21d">&#9670;&#160;</a></span>CBLACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLACK = &quot;\33[30m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91cce422ee5235f0d2131d3e0359554d" name="a91cce422ee5235f0d2131d3e0359554d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cce422ee5235f0d2131d3e0359554d">&#9670;&#160;</a></span>CBLACKBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLACKBG = &quot;\33[40m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a353b592da02899964123e6f441105ee7" name="a353b592da02899964123e6f441105ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353b592da02899964123e6f441105ee7">&#9670;&#160;</a></span>CBLINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLINK = &quot;\33[5m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67d6ab6699c80ef005d0bccf4aae0bac" name="a67d6ab6699c80ef005d0bccf4aae0bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d6ab6699c80ef005d0bccf4aae0bac">&#9670;&#160;</a></span>CBLINK2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLINK2 = &quot;\33[6m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57585ec3143257e6bf91d9a74f85f919" name="a57585ec3143257e6bf91d9a74f85f919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57585ec3143257e6bf91d9a74f85f919">&#9670;&#160;</a></span>CBLUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLUE = &quot;\33[34m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3757ad7d51e06230eacefb85dfcfdc48" name="a3757ad7d51e06230eacefb85dfcfdc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3757ad7d51e06230eacefb85dfcfdc48">&#9670;&#160;</a></span>CBLUE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLUE2 = &quot;\33[94m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19c7f2d0c8de956afe519233f7b19ffc" name="a19c7f2d0c8de956afe519233f7b19ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c7f2d0c8de956afe519233f7b19ffc">&#9670;&#160;</a></span>CBLUEBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLUEBG = &quot;\33[44m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed9e9a21b7474fbc5196e5c20ef2dcb7" name="aed9e9a21b7474fbc5196e5c20ef2dcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9e9a21b7474fbc5196e5c20ef2dcb7">&#9670;&#160;</a></span>CBLUEBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBLUEBG2 = &quot;\33[104m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf508c488d8faa707ffb113dd5417f45" name="aaf508c488d8faa707ffb113dd5417f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf508c488d8faa707ffb113dd5417f45">&#9670;&#160;</a></span>CBOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CBOLD = &quot;\33[1m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e620c7114f1dfd1fed11f80679a3bd5" name="a0e620c7114f1dfd1fed11f80679a3bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e620c7114f1dfd1fed11f80679a3bd5">&#9670;&#160;</a></span>CEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CEND = &quot;\33[0m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e16821b33c7b74208c095a576bd8ad3" name="a5e16821b33c7b74208c095a576bd8ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e16821b33c7b74208c095a576bd8ad3">&#9670;&#160;</a></span>CGREEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREEN = &quot;\33[32m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9b348aa1c52545134581468f5c55453" name="aa9b348aa1c52545134581468f5c55453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b348aa1c52545134581468f5c55453">&#9670;&#160;</a></span>CGREEN2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREEN2 = &quot;\33[92m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a488937a7ea9a648694249faba6e47973" name="a488937a7ea9a648694249faba6e47973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488937a7ea9a648694249faba6e47973">&#9670;&#160;</a></span>CGREENBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREENBG = &quot;\33[42m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ded334b5fd89b062c6564c31123541b" name="a2ded334b5fd89b062c6564c31123541b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ded334b5fd89b062c6564c31123541b">&#9670;&#160;</a></span>CGREENBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREENBG2 = &quot;\33[102m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a536a72ef48677b75c8f3338ef76f3943" name="a536a72ef48677b75c8f3338ef76f3943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536a72ef48677b75c8f3338ef76f3943">&#9670;&#160;</a></span>CGREY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREY = &quot;\33[90m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dad75e44f5a74c0e563d71aaab0220c" name="a7dad75e44f5a74c0e563d71aaab0220c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dad75e44f5a74c0e563d71aaab0220c">&#9670;&#160;</a></span>CGREYBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CGREYBG = &quot;\33[100m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93000e1590d237479ca68d52275b8f00" name="a93000e1590d237479ca68d52275b8f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93000e1590d237479ca68d52275b8f00">&#9670;&#160;</a></span>CITALIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CITALIC = &quot;\33[3m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a193e8d7511582417e7f99828ddac9d73" name="a193e8d7511582417e7f99828ddac9d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193e8d7511582417e7f99828ddac9d73">&#9670;&#160;</a></span>CRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CRED = &quot;\33[31m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fb055ad1d5f9a34a86bc19fb3cf7f16" name="a5fb055ad1d5f9a34a86bc19fb3cf7f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb055ad1d5f9a34a86bc19fb3cf7f16">&#9670;&#160;</a></span>CRED2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CRED2 = &quot;\33[91m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabd3e5dcf412c24c98e8dc21f1c4dfd4" name="aabd3e5dcf412c24c98e8dc21f1c4dfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd3e5dcf412c24c98e8dc21f1c4dfd4">&#9670;&#160;</a></span>CREDBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CREDBG = &quot;\33[41m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af5d676084ffe2332eede66a0aa1433" name="a3af5d676084ffe2332eede66a0aa1433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af5d676084ffe2332eede66a0aa1433">&#9670;&#160;</a></span>CREDBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CREDBG2 = &quot;\33[101m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2d9b77583da1d03bd827f33c2c0597" name="afa2d9b77583da1d03bd827f33c2c0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d9b77583da1d03bd827f33c2c0597">&#9670;&#160;</a></span>CSELECTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CSELECTED = &quot;\33[7m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accffe48aa21e767df16d7d04c57513e4" name="accffe48aa21e767df16d7d04c57513e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accffe48aa21e767df16d7d04c57513e4">&#9670;&#160;</a></span>CURL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CURL = &quot;\33[4m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8e540a0afc131cc17da0809e30741a9" name="ae8e540a0afc131cc17da0809e30741a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e540a0afc131cc17da0809e30741a9">&#9670;&#160;</a></span>CVIOLET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CVIOLET = &quot;\33[35m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a811764f322b39c941da90743b82cf6" name="a0a811764f322b39c941da90743b82cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a811764f322b39c941da90743b82cf6">&#9670;&#160;</a></span>CVIOLET2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CVIOLET2 = &quot;\33[95m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48bd82c3c6fc87d493bf4af34229d407" name="a48bd82c3c6fc87d493bf4af34229d407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bd82c3c6fc87d493bf4af34229d407">&#9670;&#160;</a></span>CVIOLETBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CVIOLETBG = &quot;\33[45m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a810d1f1a1cc432e01a10967c38bfefc7" name="a810d1f1a1cc432e01a10967c38bfefc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d1f1a1cc432e01a10967c38bfefc7">&#9670;&#160;</a></span>CVIOLETBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CVIOLETBG2 = &quot;\33[105m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae6616239d8e504201721ba2f5d16dac" name="aae6616239d8e504201721ba2f5d16dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6616239d8e504201721ba2f5d16dac">&#9670;&#160;</a></span>CWHITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CWHITE = &quot;\33[37m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ffcccd2c4dc78323af7535995baa9d9" name="a1ffcccd2c4dc78323af7535995baa9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffcccd2c4dc78323af7535995baa9d9">&#9670;&#160;</a></span>CWHITE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CWHITE2 = &quot;\33[97m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b3ed88e736851042b37336aa1f2882d" name="a7b3ed88e736851042b37336aa1f2882d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3ed88e736851042b37336aa1f2882d">&#9670;&#160;</a></span>CWHITEBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CWHITEBG = &quot;\33[47m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a353b572fed734f2da103923fb8806e4e" name="a353b572fed734f2da103923fb8806e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353b572fed734f2da103923fb8806e4e">&#9670;&#160;</a></span>CWHITEBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CWHITEBG2 = &quot;\33[107m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f00ea7467734b48c32ff7d6c2e1994" name="ad1f00ea7467734b48c32ff7d6c2e1994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f00ea7467734b48c32ff7d6c2e1994">&#9670;&#160;</a></span>CYELLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CYELLOW = &quot;\33[33m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af66bf09702cf1b81d8bf2f95487f3270" name="af66bf09702cf1b81d8bf2f95487f3270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66bf09702cf1b81d8bf2f95487f3270">&#9670;&#160;</a></span>CYELLOW2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CYELLOW2 = &quot;\33[93m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a685afefc081332084e1a6f273e11fc9d" name="a685afefc081332084e1a6f273e11fc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685afefc081332084e1a6f273e11fc9d">&#9670;&#160;</a></span>CYELLOWBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CYELLOWBG = &quot;\33[43m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc28aee581d3a16d682108f55b679c24" name="abc28aee581d3a16d682108f55b679c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc28aee581d3a16d682108f55b679c24">&#9670;&#160;</a></span>CYELLOWBG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ngsai::CYELLOWBG2 = &quot;\33[103m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
