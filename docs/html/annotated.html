<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ngsaipp: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ngsaipp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Class List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_0_" class="arrow" onclick="toggleFolder('0_')">&#9660;</span><span class="icona"><span class="icon">N</span></span><a class="el" href="namespacengsai.html" target="_self">ngsai</a></td><td class="desc">This file contains values that are useful for formatting terminal output </td></tr>
<tr id="row_0_0_" class="odd"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_0_0_" class="arrow" onclick="toggleFolder('0_0_')">&#9660;</span><span class="icona"><span class="icon">N</span></span><a class="el" href="namespacengsai_1_1algorithms.html" target="_self">algorithms</a></td><td class="desc"></td></tr>
<tr id="row_0_0_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1algorithms_1_1Segment.html" target="_self">Segment</a></td><td class="desc"></td></tr>
<tr id="row_0_1_" class="odd"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_0_1_" class="arrow" onclick="toggleFolder('0_1_')">&#9660;</span><span class="icona"><span class="icon">N</span></span><a class="el" href="namespacengsai_1_1dna.html" target="_self">dna</a></td><td class="desc"></td></tr>
<tr id="row_0_1_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1dna_1_1SequenceEnumerator.html" target="_self">SequenceEnumerator</a></td><td class="desc"></td></tr>
<tr id="row_0_2_" class="odd"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_0_2_" class="arrow" onclick="toggleFolder('0_2_')">&#9660;</span><span class="icona"><span class="icon">N</span></span><a class="el" href="namespacengsai_1_1genome.html" target="_self">genome</a></td><td class="desc"></td></tr>
<tr id="row_0_2_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1genome_1_1CpGRegion.html" target="_self">CpGRegion</a></td><td class="desc">Models the coordinates of a CpG on the genome. CpG are palyndromic sequences. Hence, if a CpG is located on a strand, another is located on the other strand (but in reverse orientation). For this reason, the strand information is always UNORIENTED. A CpG is encoded as a two GenomicRegion containing [start,end) ranges (0-based) for each strand CpG. The starts are always the position of the leftmost C on both strands and the end positions the position just after the rightmost G on both strands. This corresponds to the following schema : start end | | 5' - N N N C G N N N - 3' fw strand 3' - N N N G C N N N - 5' rv strand | | start end </td></tr>
<tr id="row_0_2_1_" class="odd"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1genome_1_1GenomeRegion.html" target="_self">GenomeRegion</a></td><td class="desc"></td></tr>
<tr id="row_0_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1BedReader.html" target="_self">BedReader</a></td><td class="desc">A class to perform sequencial reading from a BED file using the <a class="el" href="classngsai_1_1BedReader.html#a8b5cfe6bdb68efacd467698896f850d4" title="Reads the next record in the file.">getNext()</a> method. Currently BED 6 format is handled </td></tr>
<tr id="row_0_4_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1BedRecord.html" target="_self">BedRecord</a></td><td class="desc"></td></tr>
<tr id="row_0_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1CcsKineticExtractor.html" target="_self">CcsKineticExtractor</a></td><td class="desc">The <a class="el" href="classngsai_1_1CcsKineticExtractor.html" title="The CcsKineticExtractor allows to extract inter pulse durations (IPDs) and pulse widths (PWDs) in giv...">CcsKineticExtractor</a> allows to extract inter pulse durations (IPDs) and pulse widths (PWDs) in given region from mapped PacBio CCSs. The region are always specified in reference coordinates (the reference onto which the CCS is mapped). The window specifies a region, on one of the reference strands, as a semi open interval [from, to). Then, if the CCS maps over this reference region, the CCS sequence, IPDs and PWDs values corresponding to the window are extracted. The sequence, IPDs and PWDs are always returned in 5' to 3' order with respect to the window strand (that is on the reference) </td></tr>
<tr id="row_0_6_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1DiPositionKineticModel.html" target="_self">DiPositionKineticModel</a></td><td class="desc">Made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model is a special case of the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a>. The <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> accounted for all N = ((L*L) - L) / 2 pair-wise position interaction whereas this one only considers L-1 interactions between any two directly neighbouring positions in the window. Except for this, everything is the same as in <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> </td></tr>
<tr id="row_0_7_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1DiPositionNormalizedKineticModel.html" target="_self">DiPositionNormalizedKineticModel</a></td><td class="desc">Made to model the normalized IPD and PWD signal from PacBio CCS. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1DiPositionKineticModel.html" title="The DiPositionKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">DiPositionKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model is a special case of the <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a>. The <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a> accounted for all N = ((L*L) - L) / 2 <br  />
 pair-wise position interaction whereas this one only considers L-1 interactions between any two directly neighbouring positions in the window. Except for this, everything is the same as in <a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">PairWiseNormalizedKineticModel</a> </td></tr>
<tr id="row_0_8_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1KineticClassifier.html" target="_self">KineticClassifier</a></td><td class="desc"></td></tr>
<tr id="row_0_9_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1KineticModel.html" target="_self">KineticModel</a></td><td class="desc">Abstract class providing an interface to derive for classes that implement a statistical model of the kinetic signal of PacBio CCSs </td></tr>
<tr id="row_0_10_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1KineticSignal.html" target="_self">KineticSignal</a></td><td class="desc"><a class="el" href="classngsai_1_1KineticSignal.html" title="the KineticSignal class is designed to be a data structure to store the DNA sequence and kinetic - IP...">KineticSignal</a> class is designed to be a data structure to store the DNA sequence and kinetic - IPD and PWD - information in a given strech of DNA. An instance has a size, that is the length of the DNA strech, in bp, that is modelled. The default contructor allow to create empy - 0bp - streches and to add data later using the setter methods. In this case, the size is set at the 1st use of a setter. Except this 1st insertion - on an empty instance - data inserted must have the same size as the instance </td></tr>
<tr id="row_0_11_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1KmerData.html" target="_self">KmerData</a></td><td class="desc">Class allowing to model a kmer together with per sequence position IPD and PWD data. Each of the sequence position corresponds to the same data vector index </td></tr>
<tr id="row_0_12_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1KmerMap.html" target="_self">KmerMap</a></td><td class="desc">The <a class="el" href="classngsai_1_1KmerMap.html" title="The KmerMap is a template class allowing to create a map storing per kmer kinetic information....">KmerMap</a> is a template class allowing to create a map storing per kmer kinetic information. It is designed to allow O(k) insertion and O(1) query operations using a Rabin-Karp hashing approach. Each kmer is kinetic information is stored in a pair, together with the number of insertions in the map made for the corresponding kmer. The memory footprint of the map is N**k where N is the number of character in the alphabet - the alphabet is defined in ngsai::base_code in <a class="el" href="dna__utility_8hpp.html">dna/dna_utility.hpp</a>) - and k is the kmer size </td></tr>
<tr id="row_0_13_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1NormalizedKineticModel.html" target="_self">NormalizedKineticModel</a></td><td class="desc">Made to model the IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. In the end, as for the <a class="el" href="classngsai_1_1RawKineticModel.html" title="The RawKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">RawKineticModel</a> class, the signal models contains 2*L different distributions of signal. The distributions at each position are empiric and are made of 2*L histograms h_ipd(1), h_pwd(1), h_ipd(2), h_pwd(2) ..., h_ipd(L), h_pwd(L). The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL corresponding to a DNA sequence S s1, s2, ..., sL, each value xi and yi will be normalized into n(xi) n(yi) using a normalizing function accounting for the sequence context S. Then each histogram h_ipd(i) and h_pwd(i) will be added a count corresponding to the value n(xi) an n(yi) respectively. h_ipd(1) will be added a count corresponding to n(x1), h_ipd(2) will be added a count corresponding to n(x2), ..., h_ipd(L) will be added a count corresponding to n(xL). The same will apply for the PWD histograms with normalized Y values. Once the histograms have been filled, the model can be normalized in order to transform the 2*L histograms into 2*L probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL corresponding to a sequence S s1, s2, ..., sL. The likelihood corresponds to : p(n(x1) | h_ipd(1)) * p(n(y1) | h_pwd(1)) *... * p(n(xL) | h_ipd(L)) * p(n(xL) | h_pwd(L)) where p(n(xi) | h(i)) means the probability of observing the normalized value n(x) at the i-th position of the window, according to the density modeled in the histogram h(i) </td></tr>
<tr id="row_0_14_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1PairWiseKineticModel.html" target="_self">PairWiseKineticModel</a></td><td class="desc">Made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. This model accounts for pair-wise relaitions ships between any two positions in the window. There are exactly N = ((L*L) - L) / 2 pair-wise relations. The signal in the Lbp window is modelled using 2*N different distributions of signal - N for IPD and N for PWD signal. Each distribution is modelled by a 2D histogram representing the signal at one position p in the window with respect to the signal found at the paired position q in the window where p != q. Overall the window signal is modelled by 2*N histograms h_ipd_p_q and h_pwd_p_q : h_ipd_1_2, h_ipd_1_3, ..., h_ipd_1_L, h_ipd_2_3, ..., h_ipd_2_L, ..., h_ipd_L-1_L and h_pwd_1_2, h_pwd_1_3, ..., h_pwd_1_L, h_pwd_2_3, ..., h_pwd_2_L, ..., h_pwd_L-1_L. The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each pair of positions in the window. At this moment, the histograms are count histograms. Once the histograms have been filled, the model can be normalized in order to transform the 2*N histograms into 2*N probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL. The likelihood corresponds to : p(x1,x2 | h_ipd_1_2) * p(x1,x3 | h_ipd_1_3) *... * p(x1,xL | h_ipd_1_L) </td></tr>
<tr id="row_0_15_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1PairWiseNormalizedKineticModel.html" target="_self">PairWiseNormalizedKineticModel</a></td><td class="desc">The <a class="el" href="classngsai_1_1NormalizedKineticModel.html" title="The NormalizedKineticModel class is made to model the IPD and PWD signal from PacBio CCS....">NormalizedKineticModel</a> class is made to model the IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. Instead of modelling the raw kinetic signal like the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> class, this class models kinetic ratios (normalized). Each stretch of kinetic values (IPD or PWD) x1,x2,...,xL is normalized by the expected kinetic signal given the DNA sequence s1,s2,...,sL associated to the kinetic values. In the end, as for the <a class="el" href="classngsai_1_1PairWiseKineticModel.html" title="The PairWiseKineticModel class is made to model the raw IPD and PWD signal from PacBio CCS....">PairWiseKineticModel</a> class, the signal models contains 2*N different distributions of signal modelling all possible N = ((L*L) - L) / 2 pair-wise position relation between any position p and q where p != q : h_ipd_1_2, h_ipd_1_3, ..., h_ipd_1_L, h_ipd_2_3, ..., h_ipd_2_L, ..., h_ipd_L-1_L and h_pwd_1_2, h_pwd_1_3, ..., h_pwd_1_L, h_pwd_2_3, ..., h_pwd_2_L, ..., h_pwd_L-1_L. The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL corresponding to a DNA sequence S s1, s2, ..., sL, each value xi and yi will be normalized into n(xi) n(yi) using a normalizing function accounting for the sequence context S. Then each histogram h_ipd_p_q and h_pwd_p_q will be added a count corresponding to the pairs of values n(xp), n(xq) an n(yp), n(yq) respectively. Once the histograms have been filled, the model can be normalized in order to transform the 2*N histograms into 2*N probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL corresponding to a sequence S s1, s2, ..., sL. The likelihood corresponds to : p(n(x1),n(x2) | h_ipd_1_2) * p(n(x1),n(x3) | h_ipd_1_3) *... * p(n(x1),n(xL) | h_ipd_1_L) * p(n(x2),n(x3) | h_ipd_2_3) * ... * p(n(x2),n(xL) | h_ipd_2_L) * ... * p(n(xL-1),n(xL) | h_ipd_L-1_L) * p(n(y1),n(y2) | h_pwd_1_2) * p(n(y1),n(y3) | h_pwd_1_3) * ... * p(n(y1),n(yL) | h_pwd_1_L) * p(n(y2),n(y3) | h_pwd_2_3) * ... * p(n(y2),n(yL) | h_pwd_2_L) * ... * p(n(yL-1),n(yL) | h_pwd_L-1_L) where p(n(xp), n(xq) | h_p_q) means the probability of observing the normalized value n(xp) at the position p and n(xq) at position q of the window, according to the density modeled in the histogram h_p_q </td></tr>
<tr id="row_0_16_" class="odd"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1RawKineticModel.html" target="_self">RawKineticModel</a></td><td class="desc">Made to model the raw IPD and PWD signal from PacBio CCS. This model models a window of IPD/PWD signal of L consecutive bp. L is named the model size. The signal in the Lbp window is modelled using 2*L different distributions of signal - L for IPD and L for PWD signal. The distributions at each position are empiric. Overall the window signal is modelled by 2*L histograms h_ipd(1), h_ipd(2), ..., h_ipd(L) and h_pwd(1), h_pwd(2), ..., h_pwd(L). The model can be trained (feed with data) in order to fill the underlying histograms and estimate the signal distributions at each position in the window. At this moment, the histograms are count histograms. If the model is feed with a vector of IPD values X x1, x2, ..., xL and a vector of PWD values Y y1, y2, ..., yL then each histogram h_ipd(i) and h_pwd(i) will be added a count corresponding to the value xi an yi respectively. h_ipd(1) will be added a count corresponding to x1, h_ipd(2) will be added a count corresponding to x2, ..., h_ipd(L) will be added a count corresponding to xL. The same will apply for the PWD histograms with Y values. Once the histograms have been filled, the model can be normalized in order to transform the 2*L histograms into 2*L probability densities. At this moment, the model can compute the likelihood of observing a a strech of signal of length L with IPDs X x1, x2, ..., xL and PWDs Y <br  />
 y1, y2, ..., yL. The likelihood corresponds to : p(x1 | h_ipd(1)) * p(y1 | h_pwd(1)) *... * p(xL | h_ipd(L)) * p(xL | h_pwd(L)) where p(xi | h(i)) means the probability of observing the value x at the i-th position of the window, according to the density modeled in the histogram h(i) </td></tr>
<tr id="row_0_17_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classngsai_1_1ThreadPool.html" target="_self">ThreadPool</a></td><td class="desc">Implements a simple pool of working threads. At construction, &lt;n&gt; threads are spawned and tries to get tasks to execute from a queue. Any access to the queue is synchonized through the use of a mutex. Jobs are added to the queue by calling addJob(task) where task is the result of std::bind(). The queue can be open - in which case the jobs are effectively added to the queues - or closed - in which case nothing can be push into the queue anymore. Stopping the pool is done through calling <a class="el" href="classngsai_1_1ThreadPool.html#a2a8767845dcae378ce14975251bbb458" title="closes the job queues and join the threads. When this methods returns, all the jobs have been run and...">join()</a> which will close the queue </td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
